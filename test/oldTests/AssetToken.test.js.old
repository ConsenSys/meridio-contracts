const expectThrow = require('./utils.js').expectThrow;
const AssetTokenAbstraction = artifacts.require('AssetToken');
const WhitelistAbstraction = artifacts.require('Whitelist');
let AT;
let WL;

const investorCap = 10;

contract('AssetToken', function(accounts) {
  beforeEach( async () => {
    WL = await WhitelistAbstraction.new({from: accounts[0]});
    AT = await AssetTokenAbstraction.new(
      10000,
      'ABC Property',
      0,
      'ABC',
      WL.address,
      investorCap,
      {from: accounts[0]}
    );
    await WL.addAddress(accounts[0], {from: accounts[0]});
    await WL.addAddress(accounts[1], {from: accounts[0]});
    await WL.addAddress(accounts[2], {from: accounts[0]});
  });

  describe('PAUSABLE', () => {
    it('can transfer when not paused', async function() {
      const state = await AT.paused();
      assert.isFalse(state);

      await AT.transfer(accounts[1], 10000, {from: accounts[0]});
      const balance = await AT.balanceOf.call(accounts[1]);
      assert.strictEqual(balance.toNumber(), 10000);
    });

    it('cannot transfer when paused', async function() {
      await AT.pause();
      const state = await AT.paused();
      assert.isTrue(state);

      return expectThrow(
        AT.transfer.call(accounts[1], 10000, {from: accounts[0]})
      );
    });

    it('can transferFrom when not paused', async () => {
      const balance0 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance0.toNumber(), 10000);

      await AT.approve(accounts[1], 100, {from: accounts[0]}); // 100
      const balance2 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance2.toNumber(), 0, 'balance2 not correct');

      AT.transferFrom.call(accounts[0], accounts[2], 20, {from: accounts[1]});
      await AT.allowance.call(accounts[0], accounts[1]);
      await AT.transferFrom(accounts[0], accounts[2], 20, {from: accounts[1]}); // -20
      const allowance01 = await AT.allowance.call(accounts[0], accounts[1]);
      assert.strictEqual(allowance01.toNumber(), 80); // =80

      const balance22 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance22.toNumber(), 20);

      const balance02 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance02.toNumber(), 9980);
    });

    it('cannot transferFrom when paused', async function() {
      await AT.pause();
      const state = await AT.paused();
      assert.isTrue(state);

      const balance0 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance0.toNumber(), 10000);

      await AT.approve(accounts[1], 100, {from: accounts[0]}); // 100

      return expectThrow(
        AT.transferFrom(accounts[0], accounts[2], 20, {from: accounts[1]})
      );
    });
  });

  describe('CREATION', () => {
    it('should create an initial balance of 10000 for the creator', async () => {
      const balance = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance.toNumber(), 10000);
    });

    it('should create with the correct vanity information', async () => {
      const name = await AT.name.call();
      assert.strictEqual(name, 'ABC Property');

      const decimals = await AT.decimals.call();
      assert.strictEqual(decimals.toNumber(), 0);

      const symbol = await AT.symbol.call();
      assert.strictEqual(symbol, 'ABC');
    });

    it('should be able to create over 2^256 - 1 (max) tokens', async () => {
      const AT2 = await AssetTokenAbstraction.new(
        '115792089237316195423570985008687907853269984665640564039457584007913129639935',
        'DEF Fund',
        0,
        'DEF',
        WL.address,
        1,
        {from: accounts[0]}
      );
      const totalSupply = await AT2.totalSupply();
      const match = totalSupply.equals('1.15792089237316195423570985008687907853269984665640564039457584007913129639935e+77');
      assert(match, 'result is not correct');
    });
  });


  describe('TRANSFERS', () => {
    it('ether transfer should be reversed', async () => {
      const balanceBefore = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balanceBefore.toNumber(), 10000);

      web3.eth.sendTransaction({from: accounts[0], to: AT.address, value: web3.toWei('10', 'Ether')}, async (err, res) => {
        expectThrow(new Promise((resolve, reject) => {
          if (err) reject(err);
          resolve(res);
        }));

        const balanceAfter = await AT.balanceOf.call(accounts[0]);
        assert.strictEqual(balanceAfter.toNumber(), 10000);
      });
    });

    it('should transfer 10000 to accounts[1] with accounts[0] having 10000', async () => {
      await AT.transfer(accounts[1], 10000, {from: accounts[0]});
      const balance = await AT.balanceOf.call(accounts[1]);
      assert.strictEqual(balance.toNumber(), 10000);
    });

    it('should fail when trying to transfer more than account balance', async () => {
      const balanceBefore = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balanceBefore.toNumber(), 10000);
      return expectThrow(AT.transfer.call(accounts[1], 10001, {from: accounts[0]}));
    });

    it('should fail Transfer event on a zero transfer', async () => {
      await expectThrow(
        AT.transfer.call(accounts[1], '0', {from: accounts[0]})
      );
    });

    // NOTE: testing uint256 wrapping is impossible in this standard token since you can't supply > 2^256 -1
    // todo: transfer max amounts
  });

  describe('transferFrom()', () => {
    it('should fail transferFrom event on a zero transfer', async () => {
      await AT.approve(accounts[1], 100, {from: accounts[0]});
      await expectThrow(
        AT.transferFrom.call(accounts[0], accounts[2], '0', {from: accounts[1]})
      );
    });

    it('should increase the investorCount when transferFrom to new address', async () => {
      const initialCount = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(initialCount.toNumber(), investorCap - 1, 'Contract was not instantiated with correct investor cap');

      await AT.approve(accounts[1], 100, {from: accounts[0]});
      await AT.transferFrom(accounts[0], accounts[2], 100, {from: accounts[1]});

      const remaining = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(remaining.toNumber(), investorCap - 2, 'Contract did not increase the number of investors');
    });

    it('should not increase the investorCount when transferFrom to old address when transferFrom done by new address', async () => {
      const initialCount = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(initialCount.toNumber(), investorCap - 1, 'Contract was not instantiated with correct investor cap');
      
      await AT.transfer(accounts[1], 1, {from: accounts[0]});
      const updatedCount0 = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(updatedCount0.toNumber(), investorCap - 2, 'Contract did not increase the number of investors');
      
      await AT.approve(accounts[2], 100, {from: accounts[0]});
      await AT.transferFrom(accounts[0], accounts[1], 1, {from: accounts[2]});
      const updatedCount1 = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(updatedCount1.toNumber(), investorCap - 2, 'Contract did not increase the number of investors');
    });
  });


  describe('INVESTOR CAP', () => {
    it('the initial investor count should include the seed account', async () => {
      const remaining = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(remaining.toNumber(), investorCap - 1, 'Contract was not instantiated with correct investor cap');
    });

    it('the investor count should increase when a new address receives tokens', async () => {
      await AT.transfer(accounts[1], 1, {from: accounts[0]});
      const remaining = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(remaining.toNumber(), investorCap - 2, 'Contract did not increase the number of investors');
    });

    it('the investor count should decrease when an address has a balance of zero', async () => {
      await AT.transfer(accounts[1], 5000, {from: accounts[0]});
      let balance = await AT.balanceOf.call(accounts[0]);
      let remaining = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(balance.toNumber(), 5000);
      assert.strictEqual(remaining.toNumber(), investorCap - 2, 'Contract did not increase the number of investors');

      await AT.transfer(accounts[1], 5000, {from: accounts[0]});
      remaining = await AT.getOpenInvestorCount({from: accounts[0]});
      balance = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance.toNumber(), 0);
      assert.strictEqual(remaining.toNumber(), investorCap - 1, 'Contract did not decrease the number of investors');
    });

    it('owner can change the investor cap', async () => {
      let remaining = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(remaining.toNumber(), investorCap - 1, 'Contract was not instantiated with correct investor cap');

      await AT.changeInvestorCapTo(1, {from: accounts[0]});

      remaining = await AT.getOpenInvestorCount({from: accounts[0]});
      assert.strictEqual(remaining.toNumber(), 0, 'Contract was not instantiated with correct investor cap');
    });

    it('cannot transfer funds to a new investor if already at the max', async () => {
      await AT.changeInvestorCapTo(1, {from: accounts[0]});
      return expectThrow(AT.transfer.call(accounts[1], 1, {from: accounts[0]}));
    });

    it('cannot transferFrom funds to a new investor if already at the max', async () => {
      await AT.changeInvestorCapTo(1, {from: accounts[0]});
      await AT.approve(accounts[1], 100, {from: accounts[0]});
      await expectThrow(
        AT.transferFrom.call(accounts[0], accounts[2], 1, {from: accounts[1]})
      );
    });

    it('only owner can change the investor cap', async () => {
      return expectThrow(AT.changeInvestorCapTo(1, {from: accounts[1]}));
    });

    it('owner cannot change the investor cap if it would be less than the current number of investors', async () => {
      return expectThrow(AT.changeInvestorCapTo(0, {from: accounts[0]}));
    });
  });

  describe('APPROVALS', () => {
    it('msg.sender should approve 100 to accounts[1]', async () => {
      await AT.approve(accounts[1], 100, {from: accounts[0]});
      const allowance = await AT.allowance.call(accounts[0], accounts[1]);
      assert.strictEqual(allowance.toNumber(), 100);
    });

    // bit overkill. But is for testing a bug
    it('msg.sender approves accounts[1] of 100 & withdraws 20 once.', async () => {
      const balance0 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance0.toNumber(), 10000);

      await AT.approve(accounts[1], 100, {from: accounts[0]}); // 100
      const balance2 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance2.toNumber(), 0, 'balance2 not correct');

      AT.transferFrom.call(accounts[0], accounts[2], 20, {from: accounts[1]});
      await AT.allowance.call(accounts[0], accounts[1]);
      await AT.transferFrom(accounts[0], accounts[2], 20, {from: accounts[1]}); // -20
      const allowance01 = await AT.allowance.call(accounts[0], accounts[1]);
      assert.strictEqual(allowance01.toNumber(), 80); // =80

      const balance22 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance22.toNumber(), 20);

      const balance02 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance02.toNumber(), 9980);
    });

    it('msg.sender approves accounts[1] of 100 & withdraws 20 once then 80.', async () => {
      const balance0 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance0.toNumber(), 10000);

      await AT.approve(accounts[1], 100, {from: accounts[0]});

      const balance2 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance2.toNumber(), 0, 'balance for account 2 not correct');

      const allowance01 = await AT.allowance.call(accounts[0], accounts[1]);
      assert.strictEqual(allowance01.toNumber(), 100);

      await AT.transferFrom(accounts[0], accounts[2], 20, {from: accounts[1]});
      const allowance02 = await AT.allowance.call(accounts[0], accounts[1]);
      assert.strictEqual(allowance02.toNumber(), 80);

      const balance22 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance22.toNumber(), 20);

      const balance02 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance02.toNumber(), 9980);

      await AT.transferFrom(accounts[0], accounts[2], 80, {from: accounts[1]});
      const allowance03 = await AT.allowance.call(accounts[0], accounts[1]);
      assert.strictEqual(allowance03.toNumber(), 0);

      const balance23 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance23.toNumber(), 100);

      const balance03 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance03.toNumber(), 9900);
    });

    it('msg.sender approves accounts[1] of 100 & withdraws 20 once then 90.', async () => {
      const balance0 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance0.toNumber(), 10000);

      await AT.approve(accounts[1], 100, {from: accounts[0]});

      const balance2 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance2.toNumber(), 0, 'balance for account 2 not correct');

      const allowance01 = await AT.allowance.call(accounts[0], accounts[1]);
      assert.strictEqual(allowance01.toNumber(), 100);

      await AT.transferFrom(accounts[0], accounts[2], 20, {from: accounts[1]});
      const allowance02 = await AT.allowance.call(accounts[0], accounts[1]);
      assert.strictEqual(allowance02.toNumber(), 80);

      const balance22 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance22.toNumber(), 20);

      const balance02 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance02.toNumber(), 9980);

      await expectThrow(AT.transferFrom.call(accounts[0], accounts[2], 90, {from: accounts[1]}));
    });

    it('attempt withdrawal from account with no allowance (should fail)', function() {
      return expectThrow(AT.transferFrom.call(accounts[0], accounts[2], 60, {from: accounts[1]}));
    });

    it('can approve an account to withdraw, then disapprove it', async () => {
      await AT.approve(accounts[1], 100, {from: accounts[0]});
      await AT.transferFrom(accounts[0], accounts[2], 60, {from: accounts[1]});
      await AT.approve(accounts[1], 0, {from: accounts[0]});
      await expectThrow(AT.transferFrom.call(accounts[0], accounts[2], 10, {from: accounts[1]}));
    });

    it('approve max (2^256 - 1)', async () => {
      await AT.approve(accounts[1], '115792089237316195423570985008687907853269984665640564039457584007913129639935', {from: accounts[0]});
      const allowance = await AT.allowance(accounts[0], accounts[1]);
      assert(allowance.equals('1.15792089237316195423570985008687907853269984665640564039457584007913129639935e+77'));
    });

    it('msg.sender approves accounts[1] of max (2^256 - 1) & withdraws 20', async () => {
      const balance0 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance0.toNumber(), 10000);

      const max = '1.15792089237316195423570985008687907853269984665640564039457584007913129639935e+77';
      await AT.approve(accounts[1], max, {from: accounts[0]});
      const balance2 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance2.toNumber(), 0, 'balance2 not correct');

      await AT.transferFrom(accounts[0], accounts[2], 20, {from: accounts[1]});
      const allowance01 = await AT.allowance.call(accounts[0], accounts[1]);
      assert.notEqual(allowance01.toString(), max);

      const balance22 = await AT.balanceOf.call(accounts[2]);
      assert.strictEqual(balance22.toNumber(), 20);

      const balance02 = await AT.balanceOf.call(accounts[0]);
      assert.strictEqual(balance02.toNumber(), 9980);
    });
  });

  describe('EVENTS', () => {
    it('should fire Transfer event properly', async () => {
      const res = await AT.transfer(accounts[1], '2666', {from: accounts[0]});
      const transferLog = res.logs.find(element => element.event.match('Transfer'));
      assert.strictEqual(transferLog.args.from, accounts[0]);
      assert.strictEqual(transferLog.args.to, accounts[1]);
      assert.strictEqual(transferLog.args.value.toString(), '2666');
    });

    it('should fire Approval event properly', async () => {
      const res = await AT.approve(accounts[1], '2666', {from: accounts[0]});
      const approvalLog = res.logs.find(element => element.event.match('Approval'));
      assert.strictEqual(approvalLog.args.owner, accounts[0]);
      assert.strictEqual(approvalLog.args.spender, accounts[1]);
      assert.strictEqual(approvalLog.args.value.toString(), '2666');
    });
  });
});
